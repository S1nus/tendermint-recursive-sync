use tendermint_light_client_verifier::types::LightBlock;
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use p3_baby_bear::BabyBear;

#[derive(Serialize, Deserialize)]
pub enum ProgramInput {
    Recursive(RecursiveProgramInput),
    Genesis {
        hash: Vec<u8>,
        header: LightBlock,
        vkey: [u32; 8],
    }
}

#[derive(Serialize, Deserialize)]
pub struct RecursiveProgramInput {
    // public values from the previous proof
    pub public_values: Vec<u8>,
    // hash of the genesis header
    pub genesis_hash: Vec<u8>,
    // proof-type dependent values
    pub recursive_proof_input: RecursiveProofInput,

    // header verified by the previous proof
    pub previous_header: LightBlock,
    // header that's being verified
    pub current_header: LightBlock,

    // vkey of the program being run
    pub current_vkey: [BabyBear; 8],

    // if proof is generated by previous ELF program, the vkey will be here
    pub proof_vkey_override: Option<[BabyBear; 8]>,
}

#[derive(Serialize, Deserialize)]
pub enum RecursiveProofInput {
    Sp1, // proof itself is passed via write_proof
    Groth16 {
        proof: Vec<u8>,
        sp1_key: Vec<u8>,
    }
}

use bincode;

/// A buffer of serializable/deserializable objects.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Buffer {
    pub data: Vec<u8>,
    #[serde(skip)]
    pub ptr: usize,
}

impl Buffer {
    pub fn new() -> Self {
        Self {
            data: Vec::new(),
            ptr: 0,
        }
    }

    pub fn from(data: &[u8]) -> Self {
        Self {
            data: data.to_vec(),
            ptr: 0,
        }
    }

    /// Set the position ptr to the beginning of the buffer.
    pub fn head(&mut self) {
        self.ptr = 0;
    }

    /// Read the serializable object from the buffer.
    pub fn read<T: Serialize + DeserializeOwned>(&mut self) -> T {
        println!("Reading {}", std::any::type_name::<T>());
        let result: T =
            bincode::deserialize(&self.data[self.ptr..]).expect("failed to deserialize");
        let nb_bytes = bincode::serialized_size(&result).expect("failed to get serialized size");
        self.ptr += nb_bytes as usize;
        result
    }

    pub fn read_slice(&mut self, slice: &mut [u8]) {
        slice.copy_from_slice(&self.data[self.ptr..self.ptr + slice.len()]);
        self.ptr += slice.len();
    }

    /// Write the serializable object from the buffer.
    pub fn write<T: Serialize>(&mut self, data: &T) {
        let mut tmp = Vec::new();
        bincode::serialize_into(&mut tmp, data).expect("serialization failed");
        self.data.extend(tmp);
    }

    /// Write the slice of bytes to the buffer.
    pub fn write_slice(&mut self, slice: &[u8]) {
        self.data.extend_from_slice(slice);
    }
}

impl Default for Buffer {
    fn default() -> Self {
        Self::new()
    }
}
